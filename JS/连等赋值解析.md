## 连等赋值解析

先**从左到右**解析各个引用，然后计算最右侧的表达式的值，最后把值**从右到左**赋给各个引用。

```js
var a = {n:1};  
var b = a; // 持有a，以回查  
a.x = a = {n:2};  
console.log(a.x);// --> undefined  
console.log(b.x);// --> {n:2}
```

事实上，解析器在接受到 `a = a.x = {n:2}` 这样的语句后，会这样做：

1. 找到 a 和 a.x 的指针。如果已有指针，那么不改变它。如果没有指针，即那个变量还没被申明，那么就创建它，指向 null。
   a 是有指针的，指向 `{n:1}`；a.x 是没有指针的，所以创建它，指向 null。
2. 然后把上面找到的指针，都指向最右侧赋的那个值，即 `{n:2}`。

**其实核心的原理就是 “.” 优先级高于 "="，所以先保留了指针，后进行了赋值，然后进行了 gc(垃圾回收) ，发现a的指向已经改变，删除了原来的指针 a.x 。**

可以这样理解

1. 声明a对象中的x属性，用于赋值，此时b指向a，同时拥有未赋值的x属性
2. 对a对象赋值，此时变量名a改变指向到对象{n:2}
3. 对步骤1中x属性，也即a原指向对象的x属性，也即b指向对象的x属性赋值

![连等赋值](https://i.loli.net/2018/10/30/5bd7ad60f06b6.jpg)