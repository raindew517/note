`str.split(/[ ] /)` 可以将多个空格去掉，但保留一个空格?

```js
var str = 'a a b   b'
str.split(/[ ] /) // ['a a a', ' b']
```



将给定的数字转化成千分位的格式，如把“10000”转化为“10,000”

```javascript
function transform(num) {
    num = num + ''
    return num.replace(/(?=(?!\b)(\d{3})+$)/g, ',')
}
```

正则

```JavaScript
var reg = /(?=(?!\b)(\d{3})+$)/g // 对象字面量声明 /patterm/flag
var reg = new RegExp('(?=(?!\\b)(\\d{3})+$)', 'g') // 构造函数声明正则，其实就是去掉了两边的 / 而且里面的每个 \ 都要转义
```

很多正则都是参考了 Perl 的正则实现

正则表达的是对字符串的一种过滤逻辑

pattern 是有规则的字符集

## 基本语法

| xyz  | 一个字符集，匹配任意一个包含的字符 | \[^xyz] | 一个否定字符集，匹配任何未包含的字符 |
| ---- | ---------------------------------- | ------- | ------------------------------------ |
| \w   | 匹配字母或数组或下划线的字符       | \W      | 匹配不是字母，数字，下划线的字符     |
| \s   | 匹配任意空白符                     | \S      | 匹配不是空白符的字符                 |
| \d   | 匹配数字                           | \D      | 匹配非数字的字符                     |
| \b   | 匹配单词的开始或结束的位置         | \B      | 匹配不是单词开头或结束的位置         |
| ^    | 匹配字符串的开始                   | $       | 匹配字符串的结束                     |

## RegExp 对象

console.dir() 可以打印 RegExp 对象

方法

- test() 返回 true 或者 false
- exec() 返回一个类数组，其实是个对象，返回的结果中的 "0" 项是完全匹配的字符串，一般没什么用，但 "1" 项会返回捕获分组的结果就很有用

属性

- source 返回当前正则表达式对象的模式文本的字符串不包含 // 和 标志位
- ignoreCase 标志位 i 忽略大小写
- global 标志位 g 全局匹配 用 string.match() 可以拿出所有匹配的字符串
- multiline 标志位 m 有换行符 \n 可以匹配多行

## 重复（量词）

| *      | 重复 0 次或更多次 |
| ------ | ----------------- |
| +      | 重复 1 次或更多次 |
| ？     | 重复 0 次或 1 次  |
| {n}    | 重复 n 次         |
| {n, }  | 重复 n 次或更多次 |
| {n, m} | 重复 n 次到 m 次  |

匹配邮箱的正则可能是 `/^[0-9a-z\-.]+@[0-9a-z\-.]+$/`

```javascript
var reg = /^https?:\/\/ke\.q{2}\.com\/$/
console.log(reg.test('https://ke.qq.com/'))
```

## 分组与捕获

`()` 里放要分组的正则，分组默认捕获

- 捕获型分组
  - 引用

  - 反向引用
- 非捕获型分组 在 `()` 里的开头 `?:`

### 引用

```js
// 引用
var ret = /(jero) love (coding|girl)/.exec('jero love girl')
console.log(ret[1]) // jero
// 直接从 RegExp.$1 可以拿到最近匹配的第一个分组结果，数字根据分组个数可以改变
// 反向引用
var reg = /<(div)>.*<\/\1>/
console.log(reg.test('<div>abcd</div>')) // true
```

## 贪婪匹配和惰性匹配

- 贪婪（greedy）匹配：普通量词
- 惰性（lazy）匹配：普通量词加 `?`
  - 非贪婪，non-greedy

## 正向前瞻和负向前瞻

look ahead positive assert 正向前瞻（零宽断言）即后面有的匹配 `/jero(?= love coding)/`

look ahead negative assert 负向前瞻（负向零宽断言）即后面没有的匹配 `/jero(?! love coding)/`

它们是匹配位置的

```js
var reg1 = /jero(?=\slove\scoding)/g
var reg2 = /jero(?!\slove\sgirl)/g
var target = 'jero love coding jero love girl jero love coding'

console.log(target.match(reg2)) // ["jero","jero"]

var target2 = 'img.jpg style.css script.js hello.jpg'
var reg3 = /\b(\w+)(?=\.jpg)\b/g // 去掉两个 \b 也可以
console.log(target2.match(reg3))
```

还有正向后瞻和负向后瞻

`(?<=foo)` 匹配前面是 `foo` 的

`(?<!foo)` 匹配前面不是 `foo` 的

## String 对象

String 常用的能使用正则的方法

- replace()
- match()
  - 和正则对象的 exec() 相比，加了 g 标志的情况下，exec() 仍然只能匹配一个，而 match() 可以匹配全部

`match`返回结果的格式，与正则对象是否有修饰符`g`有关。

```js
var string = "2017.06.27";
var regex1 = /\b(\d+)\b/;
var regex2 = /\b(\d+)\b/g;
console.log( string.match(regex1) );
console.log( string.match(regex2) );
// => ["2017", "2017", index: 0, input: "2017.06.27"]
// => ["2017", "06", "27"]
```

没有`g`，返回的是标准匹配格式，即，数组的第一个元素是整体匹配的内容，接下来是分组捕获的内容，然后是整体匹配的第一个下标，最后是输入的目标字符串。

有`g`，返回的是所有匹配的内容。

当没有匹配时，不管有无`g`，都返回`null`。

- split()
- search()
  - 返回 index，从 0 开始

## 方法比较

### **exec比match更强大**

当正则没有`g`时，使用`match`返回的信息比较多。但是有`g`后，就没有关键的信息`index`了。

而`exec`方法就能解决这个问题，它能接着上一次匹配后继续匹配：

```js
var string = "2017.06.27";
var regex2 = /\b(\d+)\b/g;
console.log( regex2.exec(string) );
console.log( regex2.lastIndex);
console.log( regex2.exec(string) );
console.log( regex2.lastIndex);
console.log( regex2.exec(string) );
console.log( regex2.lastIndex);
console.log( regex2.exec(string) );
console.log( regex2.lastIndex);
// => ["2017", "2017", index: 0, input: "2017.06.27"]
// => 4
// => ["06", "06", index: 5, input: "2017.06.27"]
// => 7
// => ["27", "27", index: 8, input: "2017.06.27"]
// => 10
// => null
// => 0

```

其中正则实例`lastIndex`属性，表示下一次匹配开始的位置。

比如第一次匹配了“2017”，开始下标是0，共4个字符，因此这次匹配结束的位置是3，下一次开始匹配的位置是4。

从上述代码看出，在使用`exec`时，经常需要配合使用`while`循环：

```js
var string = "2017.06.27";
var regex2 = /\b(\d+)\b/g;
var result;
while ( result = regex2.exec(string) ) {
	console.log( result, regex2.lastIndex );
}
// => ["2017", "2017", index: 0, input: "2017.06.27"] 4
// => ["06", "06", index: 5, input: "2017.06.27"] 7
// => ["27", "27", index: 8, input: "2017.06.27"] 10
```

### **修饰符g，对exex和test的影响**

上面提到了正则实例的`lastIndex`属性，表示尝试匹配时，从字符串的`lastIndex`位开始去匹配。

字符串的四个方法，每次匹配时，都是从0开始的，即`lastIndex`属性始终不变。

而正则实例的两个方法`exec`、`test`，当正则是全局匹配时，每一次匹配完成后，都会修改`lastIndex`。下面让我们以`test`为例，看看你是否会迷糊：

```js
var regex = /a/g;
console.log( regex.test("a"), regex.lastIndex );
console.log( regex.test("aba"), regex.lastIndex );
console.log( regex.test("ababc"), regex.lastIndex );
// => true 1
// => true 3
// => false 0

```

注意上面代码中的第三次调用`test`，因为这一次尝试匹配，开始从下标`lastIndex`即3位置处开始查找，自然就找不到了。

如果没有`g`，自然都是从字符串第0个字符处开始尝试匹配：

```js
var regex = /a/;
console.log( regex.test("a"), regex.lastIndex );
console.log( regex.test("aba"), regex.lastIndex );
console.log( regex.test("ababc"), regex.lastIndex );
// => true 0
// => true 0
// => true 0
```

### **test整体匹配时需要使用^和$**

这个相对容易理解，因为`test`是看目标字符串中是否有子串匹配正则，即有部分匹配即可。

如果，要整体匹配，正则前后需要添加开头和结尾：

```js
console.log( /123/.test("a123b") );
// => true
console.log( /^123$/.test("a123b") );
// => false
console.log( /^123$/.test("123") );
// => true
```

**split相关注意事项**

`split`方法看起来不起眼，但要注意的地方有两个的。

第一，它可以有第二个参数，表示结果数组的最大长度：

```js
var string = "html,css,javascript";
console.log( string.split(/,/, 2) );
// =>["html", "css"]
复制代码
```

第二，正则使用分组时，结果数组中是包含分隔符的：

```js
var string = "html,css,javascript";
console.log( string.split(/(,)/) );
// =>["html", ",", "css", ",", "javascript"]
```



## 资源

[在线分析正则](https://regex101.com/)