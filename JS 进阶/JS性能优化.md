# JavaScript 性能优化

语言层面的性能优化

- 内存管理
- 垃圾回收与常见 GC 算法
- V8 引擎的垃圾回收
- Performance 工具

## JavaScript 内存管理

memory management

- 内存：由可读写单元组成，表示一片可操作空间
- 管理：认为的去操作一片空间的申请、使用和释放
- 内存管理：开发者主动申请空间、使用空间、释放空间

ECMAScript 没有提供相应的操作 api，所以 JavaScript 不能像 C、C++ 那样主动的去动用 API 去操作内存空间

```js
// 申请
let obj = {};
// 使用
obj.name = "obj";
// 释放
obj = null;
```

## JavaScript 垃圾回收

- JavaScript 中内存管理是自动的
- 对象不再被引用时是垃圾
- 对象不能从根上访问到时是垃圾

可达对象

- 可以访问到的对象就是可达对象（引用、作用域链）
- 可达的标准就是从根出发是否能够被找到
- JavaScript 中的根就可以理解为是全局变量是对象

当没有路径能够找到这个对象的时候，这个对象就会被当成垃圾回收

## GC 算法

Garbage Collection，GC 可以找到内存中的垃圾、并释放和回收空间，算法就是工作时查找和回收所遵循的规则

```js
// 程序中不再需要使用的对象
function func() {
	name = 'lg'
	return `${name} is a coder`
}
func()

// 程序中不能再访问到的对象
function func() {
  const name = 'lg'
  return `${name} is a coder`
}
func
```

常见术语

- 引用计数
- 标记清除
- 标记整理
- 分带回收

## 引用计数算法实现原理

- 核心思想：设置引用树，判断当前引用数是否为 0
- 引用计数器
- 引用关系改变时修改引用数字
- 引用数字为 0 时立即回收

### 引用计数算法优缺点

**优点**

- 发现垃圾时立即回收
- 最大限度减少程序暂停
  - 程序执行必然有内存的消耗，内存终归是有上限，总归有占满内存的时候，当内存即将占满的时候，算法就被触发去释放内存，这样来达到减少程序暂停

**缺点**

- 无法回收循环引用的对象
- 时间开销大
  - 引用计数需要去维护数值的变化，对象是很多的，那耗时就也不小，这个耗时是相对于其他算法而言的

## 标记清楚算法

- 核心思想：分标记和清除两个阶段完成
- 遍历所有对象找标记活动对象
- 遍历所有对象清除没有标记对象
- 回收相应的空间

标记阶段就是先从根去查找可达对象，如果有嵌套的对象，就递归查找，然后标记对象，在清除阶段就清除回收没有标记的对象，同时清除所有标记

回收的空间会被放在空闲链表上，方便后续程序在这申请空间使用

### 标记清楚算法优缺点

**优点**

- 解决循环引用的问题（相对引用计数算法而言）

**缺点**

- 空间碎片化
  - 空间都有一部分来存储元信息（数据大小，内存地址等）的，叫“头”，一部来存储数据的，叫“域”，在回收的时候，内存空间的地址是不连续的，这样回收的空间是在各个不同的角落的，大小也不一样，如果需要申请新的内存空间的话，空闲链表中没有一样大小的空间的话，就不太合适复用
- 不会立即回收垃圾对象，清除过程其实程序是停止工作的

## 标记整理算法

- 标记整理可以看做是标记清除的增强
- 标记节点的操作和标记清除算法一致
- 清除阶段会先执行整理，移动对象位置

在清除之前先整理，把不活动的内存空间整理成一段连续的空间，然后再回收空间，这样得到的连续空间就不会有碎片化的问题

缺点也是不会立即回收垃圾对象

## V8

- V8 是最主流的 JavaScript 执行引擎
- V8 采用即时编译
- V8 内存设限 (64 位系统不超过 1.5g，32 位系统不超过 800m)
  - V8 本来是为了浏览器而做的，这样的内存够用了

### V8 如何回收新生代对象

V8 是基于分代的垃圾回收思想设计的，所以在 V8 内部是把内存分成了两个部分，一部分用来存储新生代对象，一部分用来存储老生代对象

- V8 内存空间一分为二
- 小空间用于存储新生代对象 (32M - 64 位 | 16M - 32 位)
- 新生代指的是存活时间较短的对象

新生代对象回收实现

- 回收过程采用复制算法 + 标记整理
- 新生代内存区分为二个等大小空间
- 使用空间为 From，空闲空间为 To
- 活动对象存储于 From 空间
- GC 开始，标记整理后将活动对象拷贝至 To (整理复制成连续空间)
- From 与 To 交换空间完成释放

细节说明

- 拷贝过程可能出现晋升
- 晋升就是将新生代对象移动到老生代
  - 一轮 GC 还存活的新生代需要晋升
  - To 空间的使用率超过 25%
    - To 会再次变成 From 的，那下一轮新生代进来的多了，这样 From 空间就不够用了，所以需要晋升

### V8 如何回收老生代对象

- 老生代对象存放在右侧老生代区域
- 64 位操作系统 1.4g，32 位操作系统 700m
- 老生代对象就是指存活时间较长的对象

回收实现

- 主要采用标记清除、标记整理、增量标记算法
- 首先使用标记清除完成垃圾空间的回收 (主要是这种，快)
- 采用标记整理进行空间优化 (新生代需要往老生代晋升时空间不足的时候使用)
- 采用增量标记进行效率优化

细节对比

- 新生代区域垃圾回收使用空间换时间 (因为空间分配少，时间提升却很大，所以效率还是不错的)
- 老生代区域垃圾回收不适合复制算法 (老生代空间区域大，对象数据也多)

## Performance

- GC 的目的是为了实现内存空间的良性循环
- 良性循环的基石是合理使用
- 时刻关注才能确定是否合理
- Performance 提供多种监控方式

通过 Performance 时刻监控内存，使用步骤

- 开发人员工具面板，性能
- 开启录制
- 访问具体网址
- 执行用户行为，一段时间后停止录制
- 分析性能界面中记录的内存信息

### 内存问题的体现

以下问题都是在网络正常的情况下

- 页面出现延迟加载或经常性的暂停
- 页面持续出现糟糕的性能
- 网页的性能随时间延长越来越差

### 监控内存的方式

内存问题的标准

- 内存泄漏：内存使用持续升高
- 内存膨胀：在多数设备上都存在性能问题
- 频繁垃圾回收：通过内存变化图进行分析

监控方式

- 浏览器任务管理器 (能知道页面有没有问题，但是不能定位那哪个脚本的问题)
  - 内存是 DOM 内存，JavaScript 实时内存才是我们要关注的
- TimeLine 时序图记录
- 堆快照查找分离 DOM
  - 分类 DOM 是声明了 DOM，但并没有在界面上去使用
- 判断是否存在频繁的垃圾回收
  - Timeline 中频繁的上升下降
  - 任务管理器中数据频繁的增加减小

分离 DOM

- 界面元素存活在 DOM 树上
- 垃圾对象的 DOM 节点
- 分离状态的 DOM 节点

为什么要确定频繁垃圾回收

- GC 工作时应用程序是停止的
- 频繁且过长的 GC 会导致应用假死
- 用户使用中感知应用卡顿

## 优化代码

精准测试 JavaScript 性能

- 本质上是采集大量的执行样本进行数学统计和分析
- 使用基于 Benchmark.js 的 https://jsperf.com/ 完成

### 慎用全局变量

- 全局变量定义在全局执行上下文，是所有作用域链的顶端 (局部作用域找不到的变量就不停往外找，增加了查找的时间)
- 全局执行上下文一直存在于上下文执行栈，直到程序退出 (不利于 GC)
- 如果某个局部作用域出现了同名变量则会遮蔽或污染全局 (需要考虑同名问题)

```js
// bad
var i,
  str = "";
for (i = 0; i < 1000; i++) {
  str += i;
}

// good 这个比上面那个快很多
for (let i = 0; i < 1000; i++) {
  let str = "";
  str += i;
}
```


