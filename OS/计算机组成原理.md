芯片

![image-20200909234108292](/Users/c9cu/OneDrive/NOTE/media/image-20200909234108292.png)

芯片内部的集成电路，所有的元件都是用同一块半导体材料制作而成

希尔伯特
建立一套完善的公理体系，由少数几个公理出发，推导出所有的定理和推论，将世界上的万事万物都统一到一个体系中

哥德尔不完备性定理：即便在完善的公理体系中，仍然可以找到不能被证明也不能被证伪的命题

计算机能力也是有**边界**的

摩尔定律原话已经失效，但还是告诉我们一个事实，我们的计算能力在飞速发展

阿兰图灵，图灵机，一种不断执行指令的抽象计算机（当时没有真的机器）

不能使用图灵机计算的问题，都是不可计算问题

“素数是不是有无穷多个”就是不可计算问题

无法实现：用一个通用程序去判断另一个程序是否会停止（停机问题）

世界上想解决的问题都成为问题

解决问题需要消耗芯片的计算能力--时间开销

解决问题需要消耗内存--空间开销

假如现在有一个O(n^1000)的问题，在遥远的将来我们能解决，这个问题被称为多项式时间问题（Polynomial time），也叫 P 问题

还有一种是指数形式的问题，O(n^2) ，问题如果不能在多项式时间内找到答案，就是 NP 问题

```javascript
// 假设存在程序isHalt可以判断程序f对输入input是否停机，当输入input时，f停机返回0；当输入input时，f不停机返回1
function isHalt(f, input){}// 设定test方法与isHalt结果返回相反
function test(f){ 
  if(isHalt(f, f) === 1){//当停机时，test方法终止 
    return; 
  }else{//当不停机时，test方法死循环 
    while(1){} 
  }
}
// isHalt(test, test)停机时，test(test)进入死循环，与定义的test方法相矛盾（看test代码会直接return）isHalt(test, test)不停机时，test(test)停机，与定义的test方法相矛盾（看test代码会进入死循环）
```

## 相比 32 位，64 位的优势是什么

面试官在这里给你挖了一个陷阱，因为他没有说清楚 32、64 位指的是操作系统、是软件、还是 CPU？

如果是软件，那么我们的数据库有 32 位和 64 位版本；

如果是操作系统，那么在阿里云上选择 Centos 和 Debian 版本的时候，也会有 32/64 版本；

如果是 CPU，那么有 32 位 CPU，也有 64 位 CPU。

图灵机说起了。它在计算机科学方面有两个巨大的贡献：

- 第一，它清楚地定义了计算机能力的边界，也就是可计算理论；

- 第二，它定义了计算机由哪些部分组成，程序又是如何执行的。

图灵通过数学证明了，一个问题如果可以拆解成图灵机的可执行步骤，那问题就是可计算的。另一方面，图灵机定义了计算机的组成以及工作原理，但是没有给出具体的实现。

![image-20200910002811887](/Users/c9cu/OneDrive/NOTE/media/image-20200910002811887.png)

具体的实现是 1945 年冯诺依曼和其他几位科学家在著名的 101 页报告中提出的。报告遵循了图灵机的设计，并提出用电子元件构造计算机，约定了用二进制进行计算和存储，并且将计算机结构分成以下 5 个部分：

1. 输入设备；

2. 输出设备；

3. 内存；

4. 中央处理器；

5. 总线。

这个模型也被称为冯诺依曼模型

### 内存

在冯诺依曼模型中，程序和数据被存储在一个被称作内存的线性排列存储区域。存储的数据单位是一个二进制位，英文是 bit。最小的存储单位叫作字节，也就是 8 位，英文是 byte，每一个字节都对应一个内存地址。内存地址由 0 开始编号，比如第 1 个地址是 0，第二个地址是 1， 然后自增排列，最后一个地址是内存中的字节数减 1。

我们通常说的内存都是随机存取器，也就是读取任何一个地址数据的速度是一样的，写入任何一个地址数据的速度也是一样的。

### CPU

冯诺依曼模型中 CPU 负责控制和计算。为了方便计算较大的数值，CPU 每次可以计算多个字节的数据。

如果 CPU 每次可以计算 4 个 byte，那么我们称作 32 位 CPU；

如果 CPU 每次可以计算 8 个 byte，那么我们称作 64 位 CPU。

这里的 32 和 64，称作 CPU 的位宽。

为什么 CPU 要这样设计呢？ 因为一个 byte 最大的表示范围就是 0~255。比如要计算 20000*50，就超出了byte 最大的表示范围了。因此，CPU 需要支持多个 byte 一起计算。当然，CPU 位数越大，可以计算的数值就越大。但是在现实生活中不一定需要计算这么大的数值。比如说 32 位 CPU 能计算的最大整数是 4294967295，这已经非常大了。

### 控制单元和逻辑运算单元

CPU 中有一个控制单元专门负责控制 CPU 工作；还有逻辑运算单元专门负责计算。具体的工作原理我们在指令部分给大家分析。

### 寄存器

CPU 要进行计算，比如最简单的加和两个数字时，因为 CPU 离内存太远，所以需要一种离自己近的存储来存储将要被计算的数字。这种存储就是寄存器。寄存器就在 CPU 里，控制单元和逻辑运算单元非常近，因此速度很快。

- 寄存器中有一部分是可供用户编程用的，比如用来存加和指令的两个参数，是**通用寄存器**。

- 还有一部分寄存器有特殊的用途，叫作**特殊寄存器**。比如程序指针，就是一个特殊寄存器。它存储了 CPU 要执行的下一条指令所在的内存地址。注意，程序指针不是存储了下一条要执行的指令，此时指令还在内存中，程序指针只是存储了下一条指令的地址。

- 下一条要执行的指令，会从内存读入到另一个特殊的寄存器中，这个寄存器叫作**指令寄存器**。指令被执行完成之前，指令都存储在这里。

### 总线

CPU 和内存以及其他设备之间，也需要通信，因此我们用一种特殊的设备进行控制，就是总线。总线分成 3 种：

- 一种是地址总线，专门用来指定 CPU 将要操作的内存地址。

- 还有一种是数据总线，用来读写内存中的数据。

当 CPU 需要读写内存的时候，先要通过地址总线来指定内存地址，再通过数据总线来传输数据。

- 最后一种总线叫作控制总线，用来发送和接收关键信号，比如后面我们会学到的中断信号，还有设备复位、就绪等信号，都是通过控制总线传输。同样的，CPU 需要对这些信号进行响应，这也需要控制总线。