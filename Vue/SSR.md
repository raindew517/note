# 服务端渲染基础

现在前端框架的缺点：

1. 首屏加载时间长
2. 不利于 SEO

所以有解决方案

- 通过服务端渲染首屏直出，解决首屏渲染慢以及不利于 SEO 问题 通过客户端渲染接管页面内容交互得到更好的用户体验
- 这种方式我们通常称之为现代化的服务端渲染，也叫同构渲染，所谓的同构指的就是服务端构建渲染 + 客户端构建渲染。同理，这种方式构建的应用称之为服务端渲染应用或者是同构应用。

## 什么是渲染

我们这里所说的渲染指的是**把(数据** **+** **模板)拼接到一起**的这个事儿。

我们这里要关注的并不是如何渲染，而是在哪里渲染的问题?

## 传统的服务端渲染

最早期，Web 页面渲染都是在服务端完成的，即服务端运行过程中将所需的数据结合页面模板渲染为 HTML，响应给客户端浏览器。所以浏览器呈现出来的是直接包含内容的页面。

这种模式存在很多明显的不足：

- 应用的前后端部分完全耦合在一起，在前后端协同开发方面会有非常大的阻力; 
- 前端没有足够的发挥空间，无法充分利用现在前端生态下的一些更优秀的方案; 
- 由于内容都是在服务端动态生成的，所以服务端的压力较大;

- 相比目前流行的 SPA 应用来说，用户体验一般;

## 客户端渲染

传统的服务端渲染有很多问题，但是这些问题随着客户端 Ajax 技术的普及得到了有效的解决，Ajax 技 术可以使得客户端动态获取数据变为可能，也就是说原本服务端渲染这件事儿也可以拿到客户端做了。

上面讲了客户端渲染的问题，所以现在要讲讲同构渲染了

## 同构渲染

解决得了首屏的问题，但是又有新的问题

- 开发条件所限。浏览器特定的代码，只能在某些生命周期钩子函数 (lifecycle hook) 中使用;
- 一些外部扩展库 (external library) 可能需要特殊处理，才能在服务器渲染应用程序中运行。 
- 代码需要对环境进行判断，不同的环境执行不同的代码
- 涉及构建设置和部署的更多要求。与可以部署在任何静态文件服务器上的完全静态单页面应用程序 (SPA) 不同，服务器渲染应用程序，需要处于 Node.js server 运行环境（其他环境的暂时不支持）。

服务端负载会更大，如果在高流量的环境下需要准备相应的服务器负载和服务端渲染优化

有以上问题就需要好好思考

- 首屏渲染速度是否真的很重要
- 是否真的需要 SEO

# Nuxt

Nuxt.js 是一个基于 Vue.js 的服务端渲染应用框架，它可以帮我们轻松的实现同构应用。 通过对客户端/服务端基础架构的抽象组织，Nuxt.js 主要关注的是应用的 **UI** **渲染**。

登录信息需要持久化，以前只在客户端的时候还比较简单，现在服务端渲染的时候也需要用户信息，这个比较麻烦，使用第三方包 js-cookie 放到 cookie 里就行了，只在客户端里使用，这样刷新页面的时候，请求会带上 cookie，服务端渲染的时候就可以拿到用户信息了

在使用 Vuex 的时候，actions 里定义 nuxtServerInit 函数，只会在服务端运行，它可以在这拿到用户信息，然后 commit mutation 保存信息到 Vuex 容器中

在服务端的时候 process.server 为 true，在客户端的时候 process.client 为 true

# Vue-server-renderer

使用 node 后端服务和 vue-server-renderer 结合可以实现自定义的 SSR

浏览器乱码的话，响应设置 `Content-Type` 为 `text/html; charset=utf8` 可以解决，保险起见的话，返回的 html 里也加上 `<meta charset="UTF-8">`

返回的 html 可以引入一个 html 文件作为模板，html 中用占位符 `<!--vue-ssr-outlet-->` 表示服务端渲染模板的位置

定制 meta 的标签的话，占位符可以用 `{{{ }}}` 三对大括号，这样 vue 就不会把内容转成字符串

现在页面内容能渲染了，但是客户端的 v-model，事件等都是没有的，因为还没有引入客户端代码，所以如何引入客户端代码就成了问题

![source-code-structure](../media/source-code-structure.png)

[vue 官方建议的项目结构](https://ssr.vuejs.org/guide/structure.html#code-structure-with-webpack)

这样就通过 webpack 打包出两种文件，一种是客户端的，一种是服务端的，客户端的只有 `js` 和 `manifest`，服务端只有 `bundle.json`

通过 `vue-server-renderer` 的 `createBundleRenderer` 就可以加载服务端和客户端的 manifest 就可以同构渲染了

上面说的都是值考虑的生产环境，每次代码改动都要手动重新运行打包，不适合开发阶段，在开发阶段需要配置自动打包，而且打包结果不需要生成真实的文件，放在内存中就可以了，这样的话，需要我们特殊处理 express server 和 webpack，生成打包文件到内存中我们用的是 `webpack-dev-middleware`，其实它用到的是 `momfs`，配置起来会比较麻烦，我们就用官方的 `webpack-dev-middleware` 效果是一样的

代码的大概逻辑就是，用一个 pending 中的 promise 去 await 去阻塞，这个过程中去监视文件的变化，如果文件发生变化就自动编译打包，然后将结果传出去

这里有个坑就是，因为打包出来的东西都在内存中，所以，客户端直接请求 js 文件是找不到的，所以需要 express 在收到客户端的请求的时候需要通过 `webpack-dev-middleware` 得到的中间件去处理客户端对 js 资源的请求，`server.use(clientDevMiddleware)`

开发中还有比较重要的东西就是，每次去打包后刷新页面后，页面的临时状态就丢失了，在开发一些有状态递进关系，或者表单相互依赖的场景，丢失临时状态也是比较不方便的，热更新的能力就显得有价值了，我们这个时候的场景用上 `webpack-hot-middleware` 插件就可以了，这个中间件也是注册到服务器中的

## 数据预取

Vue-server-renderer 服务端渲染只支持在 beforeCreated 和 created 两个生命周期中去获取数据，但是这里的坑就是，服务端渲染并不会等待这两个生命周期中的异步操作结束，服务端也不支持响应式数据，所以就不能在生命周期中直接拿数据

官方给的是和 Vuex 结合的方案，然后在 Vue 实例中使用，并且结合组件中的 serverPrefetch 生命周期钩子，这个是 Vue SSR 特殊为服务端渲染提供的一个生命周期钩子函数，在里面发起 vuex 的 action 并返回 promise

这里服务端和客户端的状态都要同步，不然的话，即使服务端返回了带数据的页面，客户端也会合并失败导致页面白屏

Renderer 会把 context.state 数据对象内联到页面模板中

最终发送给客户端的页面中会包含一段脚本：`window.__INITIAL_STATE__ = context.state`

客户端就要把页面中的 `window.__INITIAL_STATE__` 拿出来填充到客户端 store 容器中