# 装饰者模式

装饰模式可以在不改变一个对象本身功能的基础上给对象增加额外的新行为。装饰模式是一种用于替代继承的技术，它通过一种无须定义子类的方式来给对象动态增加职责，使用对象之间的关联关系取代类之间的继承关系。在装饰模式中引入了装饰类，在装饰类中既可以调用待装饰的原有类的方法，还可以增加新的方法，以扩充原有类的功能。

## 例子

例如有一个警察类，他负责交通协调的任务

```
var Police = function () {};

Police.prototype.work = function () {
    console.log('交通协调');
};
```

这个时候，总部下发命令，希望他协调交通的同时，还要给不遵守交通规则的人开罚单。

在非装饰者模式下，我们可以这样做给他添加‘开罚单’的职责：

```
var Police = function () {};

Police.prototype.work = function () {
    console.log('交通协调');
    console.log('开罚单');
};
```

这个时候其实是修改了原有类的代码，会导致所有该类的实例都发生改变（可能别的警察不用开罚单呢），同时也违背了开放-封闭原则。

我们可以这样改：

```
//原始的警察类
var Police = function () {};

Police.prototype.work = function () {
    console.log('交通协调');
};

// 装饰类
var TicketDecorator = function(police) {
    this.police = police;
}

TicketDecorator.prototype.work = function() {
    this.police.work();
    console.log('开罚单');
}

var police = new TicketDecorator(new Police());
police.work();
```

我们在一个对象中放入另外一个对象，形成一个聚合对象，被放入的对象（即被装饰的对象）本身没有任何的改变。

## 使用场景

当我们需要扩展一个类的功能，且使用继承会很复杂的时候，我们可以使用装饰者模式进行功能的扩展。

## 装饰者的优点

- 对于扩展一个对象的功能，装饰模式比继承更加灵活性，不会导致类的个数急剧增加。
- 可以通过一种动态的方式在运行时选择不同的具体装饰类，从而实现不同的行为。
- 可以对一个对象进行多次装饰，通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合，得到功能更为强大的对象。

## 装饰者的缺点

- 被装饰多次的对象，报错需要逐级排查，较为繁琐。
- 使用装饰者模式会产生许多小对象，这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同，大量的小对象会占用更多的系统资源，影响程序性能。