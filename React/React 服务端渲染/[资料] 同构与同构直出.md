# 同构与同构直出

## 同构直出的发展

在我们之前的扩展中有提到，前端的页面渲染经历了一开始以后端渲染为主、再到前端渲染为主的单页面应用、再到 Node 出现。

对于一般的前端渲染页面来说，由于数据是等待 JavaScript 代码在浏览器端执行之后再获取的，必然会存在响应较慢的问题，直观的表现就是白屏时间比较长，并且这种前端动态拉取数据的方式，也对 SEO 非常不利。

借助 Node 的能力，我们依然可以完成之前使用 jsp、php 等服务端渲染页面的方式去渲染页面，但是由于 Node 采用 JavaScript 作为开发语言，这给了我们更多的想象空间：我们可以共用包括页面模版、数据处理逻辑等代码，这样既能使我们的应用首屏快速渲染，也可以在客户端渲染，从而提供给用户平稳降级的能力（当服务端渲染挂掉之后还可以继续采用客户端渲染），并同时在前端支持复杂交互（不用每次交互都重新刷新页面）。

所以，这里的同构，指的前后端完全使用同一套代码，而直出，则指的是将前端的渲染逻辑移到服务端完成。

## React 实现同构直出

React 的服务端渲染，按照实现程度，一般来说有首屏同构直出，也有精确到路由级别的全页面同构直出，虽然后者在实现上更为复杂，但其原理几乎相同，所以，这里我们也不做更详细的区分。

React 之所以能够实现服务端渲染，和其采用了虚拟 DOM 有很大的关系，React 的虚拟 DOM 以对象树的形式保存在原型中，并存在前后端两种暴露原型的形式：

![img](http://p.qpic.cn/qqconadmin/0/8c170deb54be452fad19ef50a977c9f2/0)

- 在浏览器端，虚拟 Dom 通过 ReactDOM 的 Render 方法渲染到页面中。
- 在服务端，React 提供的另外两个方法：ReactDOMServer.renderToString 和 ReactDOMServer.renderToStaticMarkup 可将其渲染为 HTML 字符串。

### React 同构直出的注意事项

- DOM 的一致性

React 服务端渲染的 HTML 字节流会在浏览器解析渲染成 DOM 树，如果带有 data-reactid 属性（即采用 renderToString 函数渲染），之后 DOM 节点会由前端 React 接管，而如果此时前端本来渲染的 DOM 和接管的 DOM 节点并不一致，便有可能会导致前端无法识别 DOM 节点，并重新渲染，因此会降低执行效率。

- 不同的生命周期

在服务端渲染阶段，Component 的生命周期只会执行到 componentWillMount（该生命周期在 V17.0 之后会被移除)，即 componentDidMount 之前。

因此，我们在服务端通常会在 constructor 阶段或者服务端提前去拉取数据，从而返回已经填充了数据的 HTML 字节流，而在 componentDidMount 阶段，可以判断是否已经获取到数据从而执行兼容方案。

- 全局变量、cookie 等的使用

由于服务端渲染是在 Node 环境，因此并不具备浏览器端的 window 对象、也无法使用 cookie 等内容，如果我们的渲染过程对这些内容有所依赖，则需要在服务端设计兼容方案，在特殊情况下，部分内容甚至无法直接在服务端渲染，需要到客户端对这部分内容进行渲染。

### React 同构直出实践

对于 React 同构直出的代码实践，本课程提供了讲解视频以及示例代码，大家可以自行下载代码练习，这里不进行过多介绍。