

# Fundamentals to 函数式编程 JavaScript 

teacher: Bianca Gandolfo

### Property Access

```js
var person = []
typeof person === "array" // false
typeof person === "object" // true
```



```js
var person = [];
var plea = "wouldShe"

person.name = "Mrs. White"
person[plea] = "I would never!" // person.wouldShe
// 如果 plea 没有定义，会报错
```



```js
var y = []
y[0] = true
y[10] = false
y.length // 11
```



### Dot vs Bracket

| Dots    | Brackets         |
| ------- | ---------------- |
| strings | strings          |
|         | numbers          |
|         | quotations       |
|         | weird characters |
|         | expressions      |

#### recap

1. What is an object?
2. What is the difference between dot and bracket notation?
3. How do you add property with a key that contains special characters?
4. How do you add a property whose key and value are stored in different variables?
5. How do we loop through objects to access the values?
6. When can you only use dot notation and not bracket?
7. When can you only use brackets and not dot?
8. How do you add a property with a key that is stored in a variable?
9. How do you access an object that is inside another object?
10. How do you create an object that is nested inside another object?

### Destructuring

```js
// Omit certain values 省略具体的值
var [a, , b] = [1, 2, 3]
console.log(a, b) // 1 3

// Swap variables easily without temp
var a = 1, b = 2
[b, a] = [a, b]
console.log(a, b) // 2 1

```



### Nesting + Loops

### Nesting + Destructuring

## list transform

可以去一些库的官网直接调用库，方便测试库的一些功能

# Function In-Depth

## arguments / parameters

Arguments are passed to the function, parameters are used within the function

```js
// default parameters
const add = function(a , b = 2) {
   console.log(arguments); //logs [3]
   return a + b; 
};
add(3); //5??

const d = function (a, b, c) {
    return Array.prototype.slice.call(arguments) // arguments is a pseudo array
    // ES6 的新写法是 Array.from(arguments)
}
```

implement _.from()

```js
_.from = (arr) => {
    return Array.prototype.slice.call(arr)
}
```

## Scope

```js
var ACTUAL = null

var secondFn = function () {
    ACTUAL = localToFirstFn
}
var firstFn = function () {
    var localToFirstFn = 'first'
    scondFn()
}
firstFn()
// ACTUAL = null
```





### Advance Scope

```js
const myAlert = () => {
  let count = 0;
  return () => {
    console.log('count: ', count++);
  }
}
const funcCount1 = myAlert()
const funcCount2 = myAlert()
funcCount1() // 0
funcCount2() // 0
funcCount1() // 1
funcCount2() // 1
```



```js
const findSomeone = () => {

  const speak = () => {
    console.log(who);
  };

  let who = 'Why hello there, Prof Plum!';

  return speak;
};
const someoneSpeak = findSomeone()
someoneSpeak() // Why hello there, Prof Plum!
// speak 先会在自己的作用域里找 who，随后再在父作用域里找 who
```

curry 是让参数一个一个传入

compose 是让多函数合并

# Deep Javascript Foundations

老师是 Kyle Simpson 《你不知道的JS》系列书作者

```js
var foo = 'bar'

function bar() {
    // 在这里 console.log(foo) 只会得到 undefined
    var foo = 'baz'
}

function baz(foo) {
    foo = 'bam'
    bam = 'yay' // 这里不会报错，会在全局 scope 里去声明一个 bam，永远不要这样去声明一个变量，在严格模式下会报错，reference error，bam is not defined 而不是 reference error bam is undefined，意思就是 bam is undeclared variable
}
```

尽量使用 `'use strict'` ，js 是文件为单位的，所以每个文件都要去在上面写一个这个

```js
var foo = 'bar'

function bar() {
    var foo = 'baz'
    
    function baz(foo) {
        foo = 'bam'
        bam = 'yay'
    }
 	
    baz()
}

bar()
foo   // bar
bam   // yay
baz() // 报错
```

多使用具名函数，方便自身调用，匿名函数在栈追踪中没有有意义的名称，难以追踪调试

## lexical scope

```js
function foo(a) {
    var b = a * 2
    
    function bar(c) {
        console.log(a, b, c)
    }
    
    bar(b * 3)
}
foo(2) // 2, 4, 12
```

无论函数在**哪里**被调用，也无论它**如何**被调用，它的词法作用域都**只由**函数被声明时所处的位置所决定

