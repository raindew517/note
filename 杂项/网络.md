## 概述

### 分层体系结构

分层体系结构，各层的所有协议被称为协议栈

因特网的协议栈由 5个层次组成:物理层、链路层、网络层、运输层和应用层

自顶向下看，首先处理应用层，然后向下进行处理。

1. 应用层

**应用层是网络应用程序及它们的应用层协议存留的地方。**HTTP(它提供了Web文档的请求和传送)、SMTP (它提供了电子邮件报文的传输)和FTP (它提供两个端系统之间的文件传送)

2. 传输层

**运输层在应用程序端点之间传送应用层报文。**在因特网中，有两种运输协议，即TCP和UDP,利用其中的任一个都能运输应用层报文。TCP向它的应用程序提供了面向连接的服务。这种服务包括了应用层报文向目的地的确保传递和流量控制(即发送方/接收方速率匹配)。TCP也将长报文划分为短报文，并提供拥塞控制机制，因此当网络拥塞时，源抑制其传输速率。UDP协议向它的应用程序提供无连接服务。这是一种不提供不必要服务的服务，没有可靠性，没有流量控制，也没有拥塞控制。在本书中，我们把运输层的分组称为报文段 (segment) 

3. 网络层

**网络层负责将称为数据报(datagram) 的网络层分组从一台主机移动到另一台主机。**在一台源主机中的因特网运输层协议(TCP或UDP)向网络层递交运输层报文段和目的地址，就像你通过邮政服务寄信件时提供一个目的地址一样。**通常把它简单地称为IP层，这反映了 IP是将因特网连接在一起的黏合剂这样的事实。**

4. 链路层

由链路层提供的服务取决于应用于该链路的特定链路层协议。例如，某些协议基于链路提供可靠传递，从传输节点跨越一条链路到接收节点。值得注意的是，这种可靠的传递服务不同于TCP的可靠传递服务，TCP提供从一个端系统到另一个端系统的可靠交付。链路层的例子包括以太网、WiFi和电缆接入网的DOCSIS协议。因为数据报从源到目的地传送通常需要经过几条链路，一个数据报可能被沿途不同链路上的不同链路层协议处理。例如，一个数据报可能被一段链路上的以太网和下一段链路上的PPP所处理。网络层将受到来自每个不同的链路层协议的不同服务。在本书中，我们把链路层分组称为帧(frame)。

5. 物理层

虽然链路层的任务是将整个帧从一个网络元素移动到邻近的网络元素，而物理层的任务是将该帧中的一个个比特从一个节点移动到下一个节点。在这层中的协议仍然是链路相关的，并且进一步与该链路(例如，双绞铜线、单模光纤)的实际传输媒体相关。例如，以太网具有许多物理层协议:一个是关于双绞铜线的，另一个是关于同轴电缆的，还有一个是关于光纤的，等等。在每种场合中，跨越这些链路移动一个比特是以不同的方式进行的。

### OSI模型

OSI参考模型的7层是:应用层、表示层、会话层、运输层、网络层、数据链路层和物理层

OSI参考模型中附加的两个层，即表示层和会话层。表示层的作用是使通信的应用程序能够解释交换数据的含义。这些服务包括数据压缩和数据加密(它们是自解释的)以及数据描述(这使得应用程序不必担心在各台计算机中表示/ 存储的内部格式不同的问题)。会话层提供了数据交换的定界和同步功能，包括了建立检查点和恢复方案的方法。

因特网缺少了在0SI参考模型中建立的两个层次，该事实引起了一些有趣的问题: 这些层次提供的服务不重要吗？如果一个应用程序需要这些服务之一，将会怎样呢？因特网对这两个问题的回答是相同的:这留给应用程序开发者处理。应用程序开发者决定一个服务是否是重要的，如果该服务重要，应用程序开发者就应该在应用程序中构建该功能。

### 封装

在每一层，一个分组具有两种类型的字段:首部字段和有效载荷字段(payload field)o有效载荷通常是来自上一层的分组。

### 网络攻击

- 自我复制(self-replicating)
- 病毒 (virus)，需要某种形式的用户交互，恶意代码，删除，自我复制，向其他人发送同样的恶意代码
- 蠕虫(worm)，不需要交互

对服务器和网络基础设施的攻击

- 拒绝服务攻击(Denial-of Service ( DoS) attack)
  - 弱点攻击。这涉及向一台目标主机上运行的易受攻击的应用程序或操作系统发送制作精细的报文。如果适当顺序的多个分组发送给一个易受攻击的应用程序或操作系统，该服务器可能停止运行，或者更糟糕的是主机可能崩溃。
  - 带宽洪泛。攻击者向目标主机发送大量的分组，分组数量之多使得目标的接入链路变得拥塞，使得合法的分组无法到达服务器。 
  - 连接洪泛。攻击者在目标主机中创建大量的半开或全开TCP连接。该主机因这些伪造的连接而陷入困境，并停止接受合法的连接。

嗅探分组

接入各种恶意的网络后，它会记录每个流经的分组副本，这个被动接收机称为分组嗅探器(packet sniffer)

伪装

将具有虚假源地址的分组注入因特网的能力被称为IP哄骗(IP spoofing),而它只是一个用户能够冒充另一个用户的许多方式中的一种。

在相互信任的用户之间的通信是一种例外而不是规则

### 问题

“主机”和“端系统”之间有什么不同?列举几种不同类型的端系统。Web服务器是一种端系统吗?

答：没有区别。根据书本内容，“主机”和“终端系统”是交换使用的。



“协议” 一词常被用于描述外交关系。维基百科是怎样描述外交协议的? R3.标准对于协议为什么重要?

答：外交协议常用于描述一系列国家来往规则。这些构建完备和经过时间检验的规则可以使国家和人民生活和工作更简单。协议规则以人民准则为基础，其中的一部分已经作为现在等级地位的声明。标准对于协议来说，可以让人们创建可以相互操作的网络系统和产品。



列出6种接入技术。将它们分类为住宅接入、公司接入或广域无线接入。

答：

a)通过电话线的拨号调制解调器：家庭

b)通过电话线的DSL（Digital Subscriber Line，数字用户线）：家庭或小办公室

c)混合光纤同轴电缆：家庭

d)100M交换以太网：企业

e)无线网：家庭或企业

f)3G和4G：广域无线网



HFC传输速率在用户间是专用的还是共享的?在下行HFC信道中，可能出现碰撞吗?为什么?

答：HFC带宽是由用户共享。下行通道中，所有的包都是由头端这一个单一源发出的。因此，下行通道中没有碰撞。

题目有点多，不想看了

## 应用层

### 进程与计算机网络之间的接口

进程通过一个称为套接字 (socket) 的软件接口向网络发送报文和从网络接收报文。

套接字是同一台主机内应用 层与运输层之间的接口。由于该套接字是建立网络应用程序的可编程接口，因此套接字也称为应用程序和网络之间的应用程序编程接口 (Application Programming Interface, API)。

应用程序开发者可以控制套接字在应用层端的一切，但是对该套接字的运输层端几乎没有控制权。

应用程序开发者对于运输层的控制仅限于:

1. 选择运输层协议;
2. 也许能设定几个运输层参数，如最大缓存和最大报文段长度等(将在第3 章中涉及)。

一旦应用程序开发者选择了一个运输层协议(如果可供选择的话)，则应用程序就建立在由该协议提供的运输层服务之上。

### 进程寻址

为了向特定目的地发送邮政邮件，目的地需要有一个地址。类似地，在一台主机上运 行的进程为了向在另一台主机上运行的进程发送分组，接收进程需要有一个地址。为了标 识该接收进程，需要定义两种信息:

1. 主机的地址。
2. 在目的主机中指定接收进程的标识符。

### 运输服务

- 面向连接的服务:在应用层数据报文开始流动之前，TCP让客户和服务器互相交换运输层控制信息。这个所谓的握手过程提醒客户和服务器，让它们为大量分组的到来做好准备。在握手阶段后，一个TCP连接 (TCP connection)就在两个进程的套接字之间建立了。这条连接是**全双工**的，即连接双方的进程可以在此连接上同时进行报文收发。当应用程序结束报文发送时，必须拆除该连接。
- 可靠的数据传送服务：通信进程能够依靠TCP，无差错、按适当顺序交付所有发 送的数据。当应用程序的一端将字节流传进套接字时，它能够依靠TCP将相同的字节流交付给接收方的套接字，而没有字节的丢失和冗余。

TCP协议还具有拥塞控制机制，这种服务不一定能为通信进程带来直接好处，但能为因特网带来整体好处。当发送方和接收方之间的网络出现拥塞时，TCP的拥塞控制机制会 抑制发送进程(客户或服务器)。

### http

HTTP定义了 Web客户向Web服务器请求Web页面的方式，以及服务器向客户传 送Web页面的方式。

### 非持续链接和持续链接

“三次握手”过程，即客户向服务器发送一个小TCP报文段，服务器用一个小TCP报文段做出确认和响应，最后，客户向服务器返回确认。

往返时间 (Round・Trip Time, RTT)

三次握手中前两个部分所耗费的时间占用了一个RTT。完成了三次握手的前两个部分后，客户结合三次握手的第三部分 (确认) 向该TCP连接发 送一个HTTP请求报文。一旦该请求报文到达服务器，服务器就在该TCP连接上发送 HTML文件。该 HTTP 请求/响应用去了另一个RTT。因此，粗略地讲，总的响应时间就是两个RTT加上服务器传输HTML文件的时间。

### dns

从请求主机到本地 DNS服务器的查询是递归的，其余的查询是迭代的。

#### 缓存

在一个请求链中，当某 DNS 服务器接受一个 DNS 回答时，它将能映射缓存在本地存储器中。

由于主机和主机名 ip 地址之间的映射并不是永久的，DNS 服务器在一段时间后（通常设置为两天）将丢弃缓存的信息。

### p2p

BitToiTent是一种用于文件分发的流行P2P协议

使用一种称为最稀缺优先(rarest Erst)的技术。这种技术的思路是，针对她没有的块在她的邻居中决定 =1，最稀缺的块(最稀缺的块就是那些在她的邻居中副本数量最少的块)，并首先请求那些最 稀缺的块。这样，最稀缺块得到更为迅速的重新分发，其目标是(大致地)均衡每个块在洪流中的副本数量。

交换的激励机制常被称为“一报还一报”(tit・for・tat)，还有片(小块)、流水线、随机优先选择、残局模型和反怠慢的机制

### 视频流





### 可靠数据传输原理

网络传输中是依据分组的序号（sequence number）来确认

解决流水线的差错恢复有两种基本方法是:回退N步 (Go・Back・N, GBN)和选择重传(Selective Repeat, SR)

[GBN 实例](https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/go-back-n-protocol/index.html)

GBN协议也常被称为滑动窗口协议，为什么先要限制这些被发送的、未被确认的分组的数目为N呢？流量控制是对发送方施加限制的原因之一，学习TCP拥塞控制时分析另一个原因。

GBN发送方必须响应三种类型的事件:

- 上层的调用。当上层调用rdt.send ()时，发送方首先检查发送窗口是否已满，即是否有N个已发送但未被确认的分组。如果窗口未满，则产生一个分组并将其发送, 并相应地更新变量。如果窗口已满，发送方只需将数据返回给上层，隐式地指示 上层该窗口已满。然后上层可能会过一会儿再试。在实际实现中，发送方更可能 缓存(并不立刻发送)这些数据，或者使用同步机制(如一个信号量或标志)允许上层在仅当窗口不满时才调用rdt.send() 
- 收到一个ACK。在 GBN协议中，对序号为几的分组的确认采取累积确认(cumu­lative acknowledgment)的方式，表明接收方已正确接收到序号为n的以前且包括n 在内的所有分组。稍后讨论GBN接收方一端时，我们将再次研究这个主题。
- 超时事件。协议的名字“回退N步”来源于出现丢失和时延过长分组时发送方的行为。就像在停等协议中那样，定时器将再次用于恢复数据或确认分组的丢失。如果出现超时，发送方重传所有已发送但还未被确认过的分组。图3・20中的发送方仅使用一个定时器，它可被当作是最早的已发送但未被确认的分组所使用的定时器。如果收到一个ACK,但仍有已发送但未被确认的分组，则定时器被重新启 动。如果没有已发送但未被确认的分组，停止该定时器。

[Selective Repeat Protocol](https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/selective-repeat-protocol/index.html)

发送方的窗口内某分组超时后，就再发送这个分组

接收方在收到这个重发的分组（对于接收方来说是第一次接收到这个分组）后会把这个分组之后的所有分组也一起返回 ACK（哪怕已经确认过了）

SR 接收放窗口太大的困境：当窗口长度比序号空间小1时协议无法工作，分不清是一个新分组还是一次重传（ack在返回给接收方的时候丢失了的时候，这时候接受方的窗口向右滑动了，但是发送方还没收到 ack 不能滑动，如果超时了就会再发一次之前的分组，这时接收方是以为是新的分组）。

所以窗口长度必须小于或等于序号空间大小的一半。



### tcp

客户首先发送一个特殊的TCP报文段，服务器用另一个特殊的TCP报文段来响应，最后，客户再用第三个特殊报文段作为响应。前两个报 文段不承载“有效载荷”，也就是不包含应用层数据;而第三个报文段可以承载有效载荷。由于在这两台主机之间发送了 3个报文段，所以这种连接建立过程常被称为三次握手

TCP可从缓 存中取出并放入报文段中的数据数量受限于最大报文段长度(Maximum Segment Size, MSS)，MSS通常根据最初确定的由本地发送主机发送的最大链路层帧长。MSS通常根据最初确定的由本地发送主机发送的最大链路层帧长度(即所谓的最大传输单元(Maximum Transmission Unit, MTU))来设置。

MSS是 指在报文段里应用层数据的最大长度，而不是指包括首部的TCP报文段的最大长度。

### tcp 报文结构

tcp 首部一般是20字节（比 udp 首部多12字节），首部包括以下

- 源端口号和目的端口号，它被用于多路复用/分解来自或送到上层应用的数据

- 32比特的序号字段(sequence number field)和32比特的确认号字段(acknowledgment number field) ，

  这些字段被TCP发送方和接收方用来实现可靠数据传输服

  务

- 16比特的接收窗口字段(receivewindowfield)，该字段用于流量控制。我们很快就会看到，该字段用于指示接收方愿意接受的字节数量。

- 4比特的首部长度字段(headerlengthfield),该字段指示了以32比特的字为单位的TCP首部长度。由于TCP选项字段的原因，TCP首部的长度是可变的。(通常, 选项字段为空，所以TCP首部的典型长度是20字节。)

- 可选与变长的选项字段( options field)， 该字段用于发送方与接收方协商最大报文
  段长度(MSS)时，或在高速网络环境下用作窗口调节因子时使用。首部字段中
  还定义了一个时间戳选项。可参见RFC 854和RFC 1323了解其他细节。

- 6比特的标志字段(flag field)。ACK比特用于指示确认字段中的值是有效的，即该报文段包括一个对已被成功接收报文段的确认。RST、SYN和FIN比特用于连接建立和拆除，我们将在本节后面讨论该问题。在明确拥塞通告中使用了CWR和ECE比特，如3. 7.2节中讨论的那样。当PSH比特被置位时，就指示接收方应立即将数据交给上层。最后，URG比特用来指示报文段里存在着被发送端的上层实体置为“紧急”的数据。紧急数据的最后一个字节由16比特的紧急数据指针字段(urgentdatapointerfield)指出。当紧急数据存在并给出指向紧急数据尾指针的时候，TCP必须通知接收端的上层实体。(在实践中，PSH、URG和紧急数据指针并
  没有使用。为了完整性起见，我们才提到这些字段。)

#### 序号

TCP报文段首部中两个最重要的字段是序号字段和确认号字段。这两个字段是TCP可靠传输服务的关键部分。

TCP把数据看成一个无结构的、有序的字节流。我们从TCP对序号的使用上可以看出这一点，因为序号是建立在传送的字节流之上，而不是建立在传送的报文段的序列之上。 一个报文段的序号(sequence number for a segment) 因此是该报文段首字节的字节流编号。 举例来说，假设主机A上的一个进程想通过一条TCP连接向主机B上的一个进程发送一个数据流。

主机A中的TCP将隐式地对数据流中的每一个字节编号。假定数据流由一个包含500 000字节的文件组成，其MSS为1000字节，数据流的首字节编号是0。该TCP将为该数据流构建500个报文段。给第一个报文段分配序号0，第二个报文 段分配序号1000,第三个报文段分配序号2000,以此类推。每一个序号被填入到相应TCP 报文段首部的序号字段中。

#### 确认号

TCP是全双工的, 因此主机A在向主机B发送数据的同时，也许也接收来自主机B的数据(都是同一条TCP 连接的一部分)。从主机B到达的每个报文段中都有一个序号用于从B流向A的数据。主机 A填充进报文段的确认号是主机A期望从主机B收到的下一字节的序号。看一些例子有助于 理解实际发生的事情。假设主机A已收到了来自主机B的编号为0 ~535的所有字节，同时假设它打算发送一个报文段给主机B。主机A等待主机B的数据流中字节536及之后的所有 字节。所以主机A就会在它发往主机B的报文段的确认号字段中填上536。

假设主机A已收到一个来自主机B的包含字节0 ~535的报文段，以及 另一个包含字节900〜1000的报文段。由于某种原因，主机A还没有收到字节536 - 899的报 文段。在这个例子中，主机A为了重新构建主机B的数据流，仍在等待字节536 (和其后的字 节)。因此，A到B的下一个报文段将在确认号字段中包含536。因为TCP只确认该流中至第一个丢失字节为止的字节，所以TCP被称为提供累积确认(cumulative acknowledgment)

最后一个例子也会引发一个重要而微妙的问题。主机A在收到第二个报文段(字节536 ~899)之前收到第三个报文段(字节900 ~ 1000)。因此，第三个报文段失序到达。 该微妙的问题是:当主机在一条TCP连接中收到失序报文段时该怎么办?有趣的是，TCP RFC并没有为此明确规定任何规则，而是把这一问题留给实现TCP的编程人员去处理。他 们有两个基本的选择:1接收方立即丢弃失序报文段(如前所述，这可以简化接收方的设 计);2接收方保留失序的字节，并等待缺少的字节以填补该间隔。显然，后一种选择对网络带宽而言更为有效，是实践中采用的方法。

#### 往返时间的估计与超时

TCP如同前面所讲的rdt协议一样，它采用超时/重传机制来处理报文段的丢失问题。

##### 估计往返时间

报文段的样本RTT (表示为SampleRTT)就 是从某报文段被发出(即交给IP) 到对该报文段的确认被收到之间的时间量。大多数TCP的实现仅在某个时刻做一次SampleRTT测量，而不是为每个发送的报文段测量一个SampleRTT

由于路由器的拥塞和端系统负载的变化，这些报文段的SampleRTT值会随之波 动。由于这种波动，任何给定的SampleRTT值也许都是非典型的。因此，为了估计一个典型的RTT,自然要采取某种对SampleRTT取平均的办法。TCP维持一个SampleRTT均值 (称为EstimatedRTT)，一旦获得一个新SampleRTT时，TCP就会根据下列公式来更新EstimatedRTT:

EstimatedRTT = (1 - a ) • EstimatedRTT + a • SampleRTT 

上面的公式是以编程语言的语句方式给出的，即EstimatedRTT的新值是由以前的EstimatedRTT值与SampleRTT新值加权组合而成的。在[RFC 6298]中给岀的a推荐值是a=0.125(即1/8), 这时上面的公式变为

EstimatedRTT = 0. 875 • EstimatedRTT + 0. 125 • SampleRTT

[RFC 6298]定义了 RTT偏差 DevRTT, 用于估算SampleRTT 一般会偏离EstimatedRTT的程度:

DevRTT = (1 - b) • DevRTT + b • | SampleRTT - EstimatedRTT |

b的推荐值为0. 25

##### 设置和管理重传超时间隔

超时间隔设为EstimatedRTT加上一定余量。当 SampleRTT值波动较大时，这个余量应该大些;当波动较小时，这个余量应该小些。因 此，DevRTT值应该在这里发挥作用了。

Timeoutinterval = EstimatedRTT +4 • DevRTT

推荐的初始Timeoutinterval值为1秒 [RFC 6298]。同时，当出现超时后，Timeoutlnterval值将加倍，以免即将被确认的后继报文段过早出现超时。然而，只要收到报文段并更 新EstimatedRTT,就使用上述公式再次计算Timeoutinterval

TCP也使用流水线，使得发送方在任意时刻都可以有多个已发出但还未被确认的报文段存在。我们在前面已经看到，当报文段长度与往返时延之比很小时，流水线可显著 地增加一个会话的呑吐量。一个发送方能够具有的未被确认报文段的具体数量是由TCP 的流量控制和拥寒控制机制决定的。

#### 可靠数据传输

```
/*假设发送方不受TCP流量和拥塞控制的限制，来自上层数据的长度小于MSS,且数据传送只在一个
方向进行。*/ 
NextSeqNum=InitialSeqNumber 
SendBase=InitialSeqNumber
loop (永远) {
	switch (事件)
  事件: 从上面应用程序接收到数据e 
    生成具有序号NextSeqNum的TCP报文段
    if (定时器当前没有运行) 
    	启动定时器
    向IP传递报文段 
    NextSeqNum=NextSeqNum+length(data)
    break;
  事件:定时器超时
    重传具有最小序号但仍未应答的报文段
    启动定时器
    break;
  事件: 收到ACK,具有ACK字段值y
    if (y > SendBase) {
    	SendBase=y
    	if (当前仍无任何应答报文段) 启动定时器
    }
    break;
} /*结束永远循环*/
```



每次TCP重传时都会将下一次的超时间隔设为先前值的两倍，而不是用从EstimatedRTT 和DevRTT推算出的

产生TCP ACK的建议

|                             事件                             |                        TCP接收方动作                         |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
| 具有所期望序号的按序报文段到达。所有在期望序号及以前的数据都已经被确认 | 延迟的ACK。对另一个按需报文段的等待最多等待500ms。如果下一个按序报文段在这个时间间隔内没有到达，则发送一个ACK |
| 具有所期望序号的按序报文段到达，另一个按序报文段等待ACK传输  |          立即发送单个积累ACK，以确认两个按序报文段           |
|            比期望序号大的失序报文到达，监测出间隔            | 立即发送冗余ACK，指示下一个期待字节的序号（其为间隔的低端的序号） |
|           能部分或完全填充接收数据间隔的报文段到达           |         倘若该报文段起始于间隔的低端，则立刻发送ACK          |





































































































































## 反向代理

反向代理（reverse proxy）：是指以代理服务器来接受网络请求，并将请求转发给内部的服务器，并且将内部服务器的返回，就像是二房东一样。
一句话解释反向代理 & 正向代理：反向代理隐藏了真正的服务器，正向代理隐藏了真正的客户端。
