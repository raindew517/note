

1. 原码是符号位加上真值的绝对值，即用第一位表示符号位，其余位表示值。
2. 正数的反码是其本身。负数的反码是在原码的基础上，符号位不变，其余按位取反。
3. 正数的补码是其本身。负数的补码是在原码的基础上，符号位不变，其余按位取反，最后加1。
4. 计算机进行符号运算时，会以补码表示，符号位和数字位会一起参与运算。

a-b实际转换为[a-b]补=[a]补+[-b]补

0x7FFFFFFFFFFFFFFF+1=0X8000000000000000，那么

a-b=0Xf000000000000000-0X8000000000000000+1

=0X7000000000000001

=16^15*7+16^0*1

=2^60*7+1

=2^60*(2^2+2^1+2^0)+1

=2^62+2^61+2^60+1



类型转换，三元运算符先**“分清是非”**，再决定今后该走哪条路，“==”运算符比较**“喜欢”**Number类型。（我就不严谨地这么一说，若要刨根问底，请看《JavaScript权威指南》）

```js
Boolean([]); //true
Number([]); //0
Number({}); // NaN
Number(false); //0
```

因此：

```js
console.log(([])?true:fasle);// => console.log((true)?true:false);
console.log([]==false?true:false); // => console.log(0==0?true:false);
console.log(({}==false)?true:false); // => console.log((NaN==0)?true:false);
```

**“==”运算符（两个操作数的类型不相同时）**

- 如果一个值是null，另一个值是undefined，则它们相等
- 如果一个值是数字，另一个值是字符串，先将字符串转换为数学，然后使用转换后的值进行比较。
- 如果其中一个值是true，则将其转换为1再进行比较。如果其中的一个值是false，则将其转换为0再进行比较。
- 如果一个值是对象，另一个值是数字或字符串，则将对象转换为原始值，再进行比较。

------

**对象到数字的转换**

- 如果对象具有valueOf()方法，后者返回一个原始值，则JavaScript将这个原始值转换为数字（如果需要的话）并返回一个数字。
- 否则，如果对象具有toString()方法，后者返回一个原始值，则JavaScript将其转换并返回。（对象的toString()方法返回一个字符串直接量（作者所说的原始值），JavaScript将这个字符串转换为数字类型，并返回这个数字）。
- 否则，JavaScript抛出一个类型错误异常。

------

**空数组转换为数字0**

- 数组继承了默认的valueOf()方法，这个方法返回一个对象而不是一个原始值，因此，数组到数学的转换则调用toString()方法。空数组转换为空字符串，空字符串转换为数字0.



## Javascript中实现跨域的方式总结

- 第一种方式：jsonp请求；jsonp的原理是利用<script>标签的跨域特性，可以不受限制地从其他域中加载资源，类似的标签还有<img>.
- 第二种方式：document.domain；这种方式用在主域名相同子域名不同的跨域访问中
- 第三种方式：window.name；window的name属性有个特征：在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。
- 第四种方式：window.postMessage；window.postMessages是html5中实现跨域访问的一种新方式，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源。
- 第五种方式：CORS；CORS背后的基本思想，就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是应该失败。
- 第六种方式：Web Sockets；web sockets原理：在JS创建了web socket之后，会有一个HTTP请求发送到浏览器以发起连接。取得服务器响应后，建立的连接会使用HTTP升级从HTTP协议交换为web sockt协议。



## 老王有两个孩子，已知至少有一个孩子是在星期二出生的男孩。问：两个孩子都是男孩的概率是多大？

[答案](https://blog.csdn.net/u012662688/article/details/52813387)



## TCP连接建立(“三次握手”)

分为三步：

（1）客户机的TCP向服务器的TCP发送一个连接请求报文段，其中不含应用层数据，首部中的SYN标志位被置为1。客户机会随机选择一个起始序号seq=x(连接请求报文不携带数据，但要消耗一个序号)。(SYN = 1, seq = x)

（2）服务器的TCP收到连接请求报文段后，如同意建立连接，就向客户机发回确认，并为该TCP连接分配TCP缓存和变量。确认报文段中SYN和ACK位都被置为1，确认号字段的值为x+1，并且服务器随机产生起始序号seq = y(确认报文不携带数据，但也要消耗掉一个序号)。确认报文段同样不包含应用层数据。(SYN = 1, ACK = 1, seq = y, ack = x+1)

（3）当客户机收到确认报文段后，还要向服务器给出确认，并且也要分配缓存和变量。报文段的ACK标志位被置1，序号字段为x+1，确认号字段为ack = y+1。该报文段可以携带数据，如果不携带数据则不消耗序号。(ACK = 1, seq = x+1, ack = y+1)



​    在成功完成以上三步之后，TCP连接就建立了，接下来就可以传送应用层数据了。TCP提供的是全双工通信，因此通信双方的应用进程在任何时候都能发送数据。

​    另外，服务器端的资源是在完成第二次握手时分配的，而客户端的资源是在完成第三次握手时分配的。这使得服务器易于受到SYN洪泛攻击



## TCP连接的释放(“四次挥手”)

分为四步：

（1）客户机打算关闭连接，就向其TCP发送一个连接释放报文段，并停止再发送数据，主动关闭TCP连接，该报文段的FIN标志位被置1，seq = u，它等于前面已传送过的数据的最后一个字节的序号加1(FIN报文段即使不携带数据，也要消耗掉一个序号)。TCP是全双工的，可以想象成是一条TCP连接上有两条数据通路。当发送FIN报文时，发送FIN的一端就不能再发送数据，也就是关闭了其中一条数据通路，但对方还可以发送数据。(FIN = 1, seq = u)

（2）服务器收到连接释放报文段后即发出确认，确认号是ack = u+1，而这个报文段自己的序号是v，等于它前面已传送过的数据的最后一个字节的序号加1。此时，从客户机到服务器方向的连接就释放了，TCP连接处于半关闭状态。但服务器若发送数据，客户机任要接收，即从服务器到客户机方向的连接没有关闭。(ACK = 1, seq = v, ack = u+1)

（3）若服务器已经没有要向客户机发送的数据，就通知TCP释放连接，此时其发出FIN = 1的连接释放报文段。(FIN = 1, ACK = 1, seq = w, ack = u+1)

（4）客户机收到连接释放报文段后，必须发出确认。在确认报文段中，ACK字段被置为1，确认号ack = w+1，序号seq = u+1。此时TCP连接还没有释放掉，必须经过时间等待计时器设置的时间2MSL后，客户机才进入到连接关闭状态。(ACK = 1, seq = u+1, ack = w+1)

## 因此，服务器端结束TCP连接的时间要比客户端早一些。