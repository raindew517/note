### 缓存

缓存在宏观上可以分成两类：**私有缓存**和**共享缓存**。共享缓存就是那些能被各级代理缓存的缓存(咋觉得有点绕)。私有缓存就是用户专享的，各级代理不能缓存的缓存。

**浏览器对于缓存的处理是根据第一次请求资源时返回的响应头来确定的。**

Response Headers:

- cache-control: max-age=3600 单位是秒，因为服务器端和浏览器端的时间很容易不一致，绝对时间一直有缺陷，所以才会出现 `max-age` 的相对时间
  - s-maxage (单位为s) 同 max-age，只用于共享缓存（比如 CDN 缓存）
  - no-cache：表明资源部进行缓存
- expires: 绝对时间，格林尼治时间，优先级低于 cache-control，现在一般不用
- last-modified：文件最后修改的时间
- Etag：HTTP 没有给出一个明确的生成方式，所以理论上只要不会重复生成方式无所谓，比如对资源内容使用抗碰撞散列函数，使用最近修改的时间戳的哈希值，甚至只是一个版本号

Request Headers：

- if-modified-since：文件最后修改的时间，就是保存 last-modified
- if-None-Match: 与文件内容相对应的一个标记，保存的是 Etag

### 逻辑流程

![缓存的逻辑流程](https://i.loli.net/2018/10/05/5bb6d3da6c234.png)

#### 1. 强缓存

强缓存是利用 Expires 或者 Cache-Control 这两个 http response header 实现的，它们都用来表示资源在客户端缓存的有效期。

1. 浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在 response 的 header 加上 Expires 或者 Cache-Control
2. 浏览器在接收到这个资源后，会把这个资源连同所有 response header 一起缓存下来（所以缓存命中的请求返回的 header 并不是来自服务器，而是来自之前缓存的 header）
3. 浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，拿出它的 Expires跟当前的请求时间比较，如果请求时间在 Expires 指定的时间之前，就能命中缓存，否则就不行，Cache-Control 也差不多，只不过 Cache-Control 计算的是相对时间
4. 如果缓存没有命中，浏览器直接从服务器加载资源时，Expires 或 Cache-Control  Header在重新加载的时候会被更新。

#### 2. 协商缓存

当浏览器再次试图访问某个资源文件，发现缓存过期，于是会在本次请求的请求头里携带`If-Moified-Since`和`If-None-Match`这两个字段，服务器通过这两个字段来判断资源是否有修改，如果有修改则返回状态码**200和新的内容**，如果没有修改返回状态码**304**，浏览器收到200状态码，该咋处理就咋处理(相当于首次访问这个文件了)，发现返回**304**，于是知道了本地缓存虽然过期但仍然可以用，于是加载本地缓存。然后根据新的返回的响应头来设置缓存。(这一步有所差异，发现不同浏览器的处理是不同的，chrome会为304设置缓存，firefox则不会):expressionless:

#### 3. 启发式缓存阶段

我们把响应头改下：

```
Age:23146
Cache-Control: public
Date:Tue, 28 Nov 2017 12:26:41 GMT
Last-Modified:Tue, 28 Nov 2017 05:14:02 GMT
Vary:Accept-Encoding
复制代码
```

发现没？浏览器用来确定缓存过期时间的字段一个都没有！那该怎么办？有人可能会说下次请求直接进入协商缓存阶段，携带`If-Moified-Since`呗，不是的，浏览器还有个**启发式缓存阶段**😎

**根据响应头中2个时间字段 Date 和 Last-Modified 之间的时间差值，取其值的10%作为缓存时间周期。**

这就是启发式缓存阶段。这个阶段很容让人忽视，但实际上每时每刻都在发挥着作用。所以在今后的开发过程中如果遇到那种`默认缓存`的坑，不要叫嚣，不要生气，浏览器只是在遵循启发式缓存协议而已。

### 浏览器缓存策略

![浏览器缓存策略](https://i.loli.net/2018/10/05/5bb7653575839.png)

### 浏览器缓存控制

#### 1. Cache-Control

通过cache-control的指令可以控制告诉客户端或是服务器如何处理缓存。这也是11个字段中指令最多的一个，我们先来看看

**请求指令**：

| 指令            | 参数               | 说明                              |
| --------------- | ------------------ | --------------------------------- |
| no-cache        | 无                 | 强制源服务器再次验证              |
| no-store        | 无                 | 不缓存请求或是响应的任何内容      |
| max-age=[秒]    | 缓存时长，单位是秒 | 缓存的时长，也是响应的最大的Age值 |
| min-fresh=[秒]  | 必需               | 期望在指定时间内响应仍然有效      |
| no-transform    | 无                 | 代理不可更改媒体类型              |
| only-if-cached  | 无                 | 从缓存获取                        |
| cache-extension | -                  | 新的指令标记(token)               |

**响应指令**：

| 指令             | 参数               | 说明                                           |
| ---------------- | ------------------ | ---------------------------------------------- |
| public           | 无                 | 任意一方都能缓存该资源(客户端、代理服务器等)   |
| private          | 可省略             | 只能特定用户缓存该资源                         |
| no-cache         | 可省略             | 缓存前必须先确认其有效性                       |
| no-store         | 无                 | 不缓存请求或响应的任何内容                     |
| no-transform     | 无                 | 代理不可更改媒体类型                           |
| must-revalidate  | 无                 | 可缓存但必须再向源服务器进确认                 |
| proxy-revalidate | 无                 | 要求中间缓存服务器对缓存的响应有效性再进行确认 |
| max-age=[秒]     | 缓存时长，单位是秒 | 缓存的时长，也是响应的最大的Age值              |
| s-maxage=[秒]    | 必需               | 公共缓存服务器响应的最大Age值                  |
| cache-extension  | -                  | 新指令标记(token                               |

请注意no-cache指令很多人误以为是不缓存，这是不准确的，no-cache的意思是可以缓存，但每次用应该去想服务器验证缓存是否可用。no-store才是不缓存内容。另外部分指令也可以组合使用，比如：

```
Cache-Control: max-age=100, must-revalidate, public
复制代码
```

上面指令的意思是缓存的有效时间为100秒，之后访问需要向源服务器发送请求验证，此缓存可被代理服务器和客户端缓存。

#### 2. Pragma

这是HTTP/1.0里面的一个字段，但**优先级很高**，测试发现，Chrome和Firefox中Pragma的优先级高于Cache-Control和Expires，为了向下兼容，这个字段依然发挥着它的作用。🤔一般可能我们会这么用：

```
<meta http-equiv="Pragma" content="no-cache">
复制代码
```

Pragma属于通用首部字段，在客户端上使用时，常规要求我们往html上加上上面这段meta元标签（而且可能还得[做些hack放到body后面去](https://link.juejin.im?target=https%3A%2F%2Fsupport.microsoft.com%2Fzh-cn%2Fkb%2F222064)。

事实上这种禁用缓存的形式用处很有限：

1. 仅有IE才能识别这段meta标签含义，其它主流浏览器仅能识别`Cache-Control: no-store`的meta标签(见[出处](https://link.juejin.im?target=http%3A%2F%2Fsecurityevaluators.com%2Fknowledge%2Fcase_studies%2Fcaching%2F))
2. 在IE中识别到该meta标签含义，并不一定会在请求字段加上Pragma，但的确会让当前页面每次都发新请求(仅限页面，页面上的资源则不受影响)。——[浅谈浏览器http的缓存机制](https://link.juejin.im?target=http%3A%2F%2Fwww.cnblogs.com%2Fvajoy%2Fp%2F5341664.html)

读者可以自行拷贝后面模拟服务端决策的代码进行测试。

**服务端响应添加'Pragma': 'no-cache'，浏览器表现行为和强制刷新类似。**

#### 3. Expires

这又是一个HTTP/1.0的字段，上面也说过了定义的是缓存到期的绝对时间。

同样，我们也可以在html文件里直接使用:

```
<meta http-equiv="expires" content="Thu, 30 Nov 2017 11:17:26 GMT">
复制代码
```

如果设置的是已经过去的时间会怎样呢？YES！！！则刷新页面会重新发送请求。

**Pragma禁用缓存，如果又给Expires定义一个还未到期的时间，那么Pragma字段的优先级会更高。**🤖

🤖Expires有一个很大的弊端，就是它返回的是服务器的时间，但判断的时候用的却是客户端的时间，这就导致Expires很被动，因为用户有可能改变客户端的时间，导致缓存时间判断出错，这也是引入`Cache-Control:max-age`指令的原因之一。

#### 4. Last-Midified

接下来这几个字段都是校验字段，或者说是在协商缓存阶段发挥作用的字段。第一个就是Last-modified，这个字段不光协商缓存起作用，在启发式缓存阶段同样起到至关重要的作用。

在浏览器第一次请求某一个URL时，服务器端的返回状态码会是200，响应的实体内容是客户端请求的资源，同时有一个`Last-Modified`的属性标记此文件在服务器端最后被修改的时间。like this:

```
Last-Modified : Fri , 12 May 2006 18:53:33 GMT
复制代码
```

##### If-Modified-Since

当浏览器第二次请求这个URL的时候，根据HTTP协议规定，浏览器会把第一次`Last-Modified`的值存储在`If-Modified-Since`里面发送给服务端来验证资源有没有修改。like this:

```
If-Modified-Since : Fri , 12 May 2006 18:53:33 GMT
复制代码
```

服务端通过`If-Modified-Since`字段来判断在这两次访问期间资源有没有被修改过，从而决定是否返回完整的资源。如果有修改正常返回资源，状态码200，如果没有修改只返回响应头，状态码304，告知浏览器资源的本地缓存还可用。

**用途：**

- 验证本地缓存是否可用

##### If-Unmodified-Since

这个字段字面意思和`If-Modified-Since`相反，但处理方式并不是相反的。如果文件在两次访问期间没有被修改则返回200和资源，如果文件修改了则返回状态码412(预处理错误)。

**用途：**

- 与含有 `If-Range`消息头的范围请求搭配使用，实现断点续传的功能，即如果资源没修改继续下载，如果资源修改了，续传的意义就没有了。
- POST、PUT请求中，优化并发控制，即当多用户编辑用一份文档的时候，如果服务器的资源已经被修改，那么在对其作出编辑会被拒绝提交。

😈`Last-Modified`有几个缺点：没法准确的判断资源是否真的修改了，比如某个文件在1秒内频繁更改了多次，根据Last-Modified的时间(单位是秒)是判断不出来的，再比如，某个资源只是修改了，但实际内容并没有发生变化，Last-Modified也无法判断出来，因此在HTTP/1.1中还推出了`ETag`这个字段👇

#### 5. ETag

服务器可以通过某种自定的算法对资源生成一个唯一的标识(比如md5标识)，然后在浏览器第一次请求某一个URL时把这个标识放到响应头传到客户端。服务器端的返回状态会是200。

```
ETag: abc-123456
复制代码
```

ETag的值有可能包含一个 W/ 前缀，来提示应该采用弱比较算法（这个是画蛇添足，因为 If-None-Match 用且仅用这一算法）。🙄

##### If-None-Match

If-None-Match和If-Modified-Since同时存在的时候If-None-Match优先级更高。

当浏览器第二次请求这个URL的时候，根据HTTP协议规定，浏览器回把第一次ETag的值存储在If-None-Match里面发送给服务端来验证资源有没有修改。like this:

```
If-None-Match: abc-123456
复制代码
```

Get请求中，当且仅当服务器上没有任何资源的ETag属性值与这个首部中列出的相匹配的时候，服务器端会才返回所请求的资源，响应码为**200**。如果没有资源的ETag值相匹配，那么返回**304**状态码。

**POST、PUT等请求改变文件的请求，如果没有资源的ETag值相匹配，那么返回412状态码。**

##### If-Match

在请求方法为 GET) 和 HEAD的情况下，服务器仅在请求的资源满足此首部列出的 `ETag`之一时才会返回资源。而对于 PUT或其他非安全方法来说，只有在满足条件的情况下才可以将资源上传。

**用途：**

- For GET和 HEAD 方法，搭配  Range首部使用，可以用来保证新请求的范围与之前请求的范围是对同一份资源的请求。如果  ETag 无法匹配，那么需要返回 **416**（范围请求无法满足) 响应。
- 对于其他方法来说，尤其是 PUT, `If-Match` 首部可以用来避免更新丢失问题。它可以用来检测用户想要上传的不会覆盖获取原始资源之后做出的更新。如果请求的条件不满足，那么需要返回**412**(预处理错误) 响应。

当然和`Last-Modified`相比，ETag也有自己的缺点，比如由于需要对资源进行生成标识，性能方面就势必有所牺牲。😕

**关于强校验和弱校验：**

| ETag 1 | ETag 2 | Strong Comparison | Weak Comparison |
| ------ | ------ | ----------------- | --------------- |
| W/"1"  | W/"1"  | no match          | match           |
| W/"1"  | W/"2"  | no match          | no match        |
| W/"1"  | "1"    | no match          | match           |
| "1"    | "1"    | match             | match           |

